{"version":3,"sources":["../../src/auth/getJwtToken.js"],"names":["Cookies","jwtDecode","axios","logFrontendAuthError","processAxiosErrorAndThrow","createRetryInterceptor","httpClient","create","defaults","withCredentials","interceptors","response","use","cookies","decodeJwtCookie","cookieName","cookieValue","get","e","error","Object","message","customAttributes","isTokenExpired","token","exp","Date","now","refreshRequestPromises","refresh","tokenCookieName","refreshEndpoint","undefined","makeRefreshRequest","post","axiosResponse","userIsUnauthenticated","status","remove","decodedJwtToken","Error","getJwtToken","tokenRefreshEndpoint"],"mappings":"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","sourcesContent":["import Cookies from 'universal-cookie';\nimport jwtDecode from 'jwt-decode';\nimport axios from 'axios';\nimport { logFrontendAuthError, processAxiosErrorAndThrow } from './utils';\nimport createRetryInterceptor from './interceptors/createRetryInterceptor';\n\nconst httpClient = axios.create();\n// Set withCredentials to true. Enables cross-site Access-Control requests\n// to be made using cookies, authorization headers or TLS client\n// certificates. More on MDN:\n// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials\nhttpClient.defaults.withCredentials = true;\n// Add retries to this axios instance\nhttpClient.interceptors.response.use(\n  response => response,\n  createRetryInterceptor({ httpClient }),\n);\n\nconst cookies = new Cookies();\n\nconst decodeJwtCookie = (cookieName) => {\n  const cookieValue = cookies.get(cookieName);\n\n  if (cookieValue) {\n    try {\n      return jwtDecode(cookieValue);\n    } catch (e) {\n      const error = Object.create(e);\n      error.message = 'Error decoding JWT token';\n      error.customAttributes = { cookieValue };\n      throw error;\n    }\n  }\n\n  return null;\n};\n\nconst isTokenExpired = token => !token || token.exp < Date.now() / 1000;\n\nconst refreshRequestPromises = {};\n\nconst refresh = (tokenCookieName, refreshEndpoint) => {\n  if (refreshRequestPromises[tokenCookieName] === undefined) {\n    const makeRefreshRequest = async () => {\n      let axiosResponse;\n      try {\n        try {\n          axiosResponse = await httpClient.post(refreshEndpoint);\n        } catch (error) {\n          processAxiosErrorAndThrow(error);\n        }\n      } catch (error) {\n        const userIsUnauthenticated = error.response && error.response.status === 401;\n        if (userIsUnauthenticated) {\n          // Clean up the cookie if it exists to eliminate any situation\n          // where the cookie is not expired but the jwt is expired.\n          cookies.remove(tokenCookieName);\n          const decodedJwtToken = null;\n          return decodedJwtToken;\n        }\n\n        // TODO: Network timeouts and other problems will end up in\n        // this block of code. We could add logic for retrying token\n        // refreshes if we wanted to.\n        throw error;\n      }\n\n      const decodedJwtToken = decodeJwtCookie(tokenCookieName);\n\n      if (!decodedJwtToken) {\n        // This is an unexpected case. The refresh endpoint should\n        // set the cookie that is needed. See ARCH-948 for more\n        // information on a similar situation that was happening\n        // prior to this refactor in Oct 2019.\n        const error = new Error('Access token is still null after successful refresh.');\n        error.customAttributes = { axiosResponse };\n        throw error;\n      }\n\n      return decodedJwtToken;\n    };\n\n    refreshRequestPromises[tokenCookieName] = makeRefreshRequest().finally(() => {\n      delete refreshRequestPromises[tokenCookieName];\n    });\n  }\n\n  return refreshRequestPromises[tokenCookieName];\n};\n\nconst getJwtToken = async (tokenCookieName, tokenRefreshEndpoint) => {\n  try {\n    const decodedJwtToken = decodeJwtCookie(tokenCookieName);\n    if (!isTokenExpired(decodedJwtToken)) {\n      return decodedJwtToken;\n    }\n  } catch (e) {\n    // Log unexpected error and continue with attempt to refresh it.\n    logFrontendAuthError(e);\n  }\n\n  try {\n    return await refresh(tokenCookieName, tokenRefreshEndpoint);\n  } catch (e) {\n    logFrontendAuthError(e);\n    throw e;\n  }\n};\n\nexport default getJwtToken;\nexport { httpClient };\n"],"file":"getJwtToken.js"}